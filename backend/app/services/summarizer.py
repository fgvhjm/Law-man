"""Utilities for summarising retrieved clauses via Gemini LLM."""

from __future__ import annotations

import os
from textwrap import shorten
from typing import Iterable, List, Mapping, Sequence

from dotenv import load_dotenv


load_dotenv()


def _resolve_api_key() -> str:
    """Return the Gemini API key from environment variables."""

    key = os.getenv("GEMINI_API_KEY") or os.getenv("GOOGLE_API_KEY") or os.getenv("open_ai")
    if not key:
        raise RuntimeError(
            "Missing Gemini API key. Set GEMINI_API_KEY (or GOOGLE_API_KEY / open_ai) in the environment."
        )
    return key


def _format_context(hits: Sequence[Mapping[str, object]], max_items: int = 8) -> str:
    """Build a compact context string from retrieved clause hits."""

    lines: List[str] = []
    for idx, hit in enumerate(hits[:max_items], start=1):
        clause_id = hit.get("clause_id") or "unknown"
        heading = hit.get("heading") or "Untitled Clause"
        snippet = hit.get("text_snippet") or hit.get("text") or ""
        snippet = shorten(str(snippet).strip().replace("\n", " "), width=600, placeholder="…")
        lines.append(f"{idx}. Clause {clause_id} — {heading}: {snippet}")
    return "\n".join(lines)


def summarize_hits(
    query: str,
    hits: Iterable[Mapping[str, object]],
    model: str = "gemini-2.0-flash-lite",
    max_items: int = 8,
) -> str:
    """Summarise the final retrieval output using Gemini.

    Args:
        query: Original user question.
        hits: Iterable of clause dictionaries (post-rerank).
        model: Gemini model identifier.
        max_items: Number of clauses to include in the context window.

    Returns:
        A concise summary string generated by Gemini.
    """

    hits_list = list(hits)
    if not hits_list:
        return "No clauses were retrieved, so a summary could not be generated."

    api_key = _resolve_api_key()

    try:
        from google import genai as new_genai
    except ImportError:
        new_genai = None  # type: ignore[assignment]

    context = _format_context(hits_list, max_items=max_items)
    prompt = (
        "You are a legal contract assistant. Using the retrieved clauses below, "
        "craft a concise summary that answers the user's query. Reference clause IDs "
        "when helpful and stick to factual statements backed by the snippets.\n\n"
        f"User query: {query}\n\nRetrieved clauses:\n{context}\n\n"
        "Respond with 3-5 bullet points capturing the key insights relevant to the query."
    )

    summary = None
    response = None

    if new_genai is not None:
        client = new_genai.Client(api_key=api_key)
        response = client.models.generate_content(model=model, contents=prompt)
        summary = getattr(response, "text", None)
    else:
        try:
            import google.generativeai as legacy_genai
        except ImportError as exc:  # pragma: no cover - surfaced only when summary requested
            raise ImportError(
                "Gemini summarisation requires the google-genai or google-generativeai package."
            ) from exc

        legacy_genai.configure(api_key=api_key)
        model_client = legacy_genai.GenerativeModel(model)
        response = model_client.generate_content(prompt)
        summary = getattr(response, "text", None)

        if not summary and getattr(response, "candidates", None):
            parts: List[str] = []
            for cand in response.candidates:
                content = getattr(cand, "content", None)
                if not content:
                    continue
                for part in getattr(content, "parts", []) or []:
                    text = getattr(part, "text", None)
                    if text:
                        parts.append(text)
            if parts:
                summary = "\n".join(parts)
    if response is None:
        raise RuntimeError("Gemini client could not be initialised for summarisation.")

    if not summary:
        raise RuntimeError("Gemini returned an empty response while generating the summary.")

    return summary.strip()
